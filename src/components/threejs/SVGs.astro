---

---

<!-- Container for the Three.js canvas, taking up the entire viewport -->
<div class="flex flex-auto h-96" id="container"/>

<script>
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';

    export default class Sketch {
        constructor(options) {
            this.container = options.domElement;
            this.width = this.container.offsetWidth;
            this.height = this.container.offsetHeight;

            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
            this.camera.position.z = 5; // Ajusta según sea necesario. Un valor inicial está bien.

            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.width, this.height);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.container.appendChild(this.renderer.domElement);

            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.time = 0;

            this.setupResize();
            this.loadSVG().then(() => {
                this.render();
            });
        }

        setupResize() {
            window.addEventListener('resize', this.resize.bind(this));
        }

        resize() {
            this.width = this.container.offsetWidth;
            this.height = this.container.offsetHeight;
            this.renderer.setSize(this.width, this.height);
            this.camera.aspect = this.width / this.height;
            this.camera.updateProjectionMatrix();
        }

        async loadSVG() {
            const loader = new SVGLoader();

            try {
                const svgData = await loader.loadAsync('svgs/spring.svg'); // Reemplaza con la ruta a tu SVG
                const group = new THREE.Group();
                const extrudeSettings = {
                    depth: 0.15,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                };

                for (const path of svgData.paths) {
                    const material = new THREE.MeshPhongMaterial({
                        color: path.color || 0xff0055,
                        shininess: 100,
                        side: THREE.DoubleSide,
                    });

                    const shapes = SVGLoader.createShapes(path);
                    for (const shape of shapes) {
                        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                        const mesh = new THREE.Mesh(geometry, material);
                        group.add(mesh);
                    }
                    group.rotation.x = Math.PI; // Gira el SVG para que se vea correctamente
                }

                // --- Ajuste de tamaño y centrado ---
                const box = new THREE.Box3().setFromObject(group);
                const size = box.getSize(new THREE.Vector3()); // Obtiene el tamaño del bounding box
                const center = box.getCenter(new THREE.Vector3());

                const maxSize = 2; // Tamaño máximo deseado (ajústalo)

                // Calcula la escala para que quepa en el tamaño máximo
                const scale = Math.min(maxSize / size.x, maxSize / size.y, maxSize / size.z);
                group.scale.set(scale, scale, scale);

                // Centra el grupo *después* de escalarlo
                group.position.sub(center.multiplyScalar(scale));


                this.scene.add(group);
                this.mesh = group;

                // Luces
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);

            } catch (error) {
                console.error('Error loading SVG:', error);
            }
        }

        render() {
            // this.time += 0.05;

            // if (this.mesh) {
            //     // this.mesh.rotation.x = this.time * 0.1;
            //     // this.mesh.rotation.y = this.time * 0.2;
            // }

            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(this.render.bind(this));
        }
    }

    document.addEventListener('astro:page-load', () => {
        new Sketch({
            domElement: document.getElementById('container')
        });
    });
</script>